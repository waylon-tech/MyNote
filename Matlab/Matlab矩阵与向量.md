#一 矩阵与向量的创建
##1.1 向量的创建
* 1）直接输入：
	* 行向量：`a=[1,2,3,4,5]`
	* 列向量：`a=[1;2;3;4;5]`
* 2）用“:”生成向量
		* a=J:K 生成的行向量是a=[J,J+1,…,K]
	* a=J:D:K 生成行向量a=[J,J+D,…,J+m*D],m=fix((K-J)/D)
* 3）函数linspace 用来生成数据按等差形式排列的行向量
		* x=linspace(X1,X2):在X1和X2间生成100个线性分布的数据，相邻的两个数据的差保持不变。构成等差数列。
	* x=linspace(X1,X2,n): 在X1和X2间生成n个线性分布的数据，相邻的两个数据的差保持不变。构成等差数列。
* 4）函数logspace用来生成等比形式排列的行向量
	* X=logspace(x1,x2) 在x1和x2之间生成50个对数等分数据的行向量。构成等比数列，数列的第一项x(1)=10x1,x(50)=10x2
	*　X=logspace(x1,x2,n) 在x1和x2之间生成n个对数等分数据的行向量。构成等比数列，数列的第一项x(1)=10x1,x(n)=10x2
* 注：向量的的转置：x=(0,5)’
 
##1.2 矩阵的创建
* 1）直接输入：将数据括在[]中，同一行的元素用空格或逗号隔开，每一行可以用回车或是分号结束
	* 如：a=[1,2,3;3,4,5],运行后：
	* 
			a =
			     1     2     3
			     3     4     5

* 2）函数eye，生成单位矩阵
	* eye(n) :生成n*n阶单位E
	* eye(m,n):生成m*n的矩阵E，对角线元素为1，其他为0
	* eye(size(A))：生成一个矩阵Ａ大小相同的单位矩阵
	* eye(m,n,classname):对角线上生成的元素是1，数据类型用classname指定。其数据类型可以是：duoble、single、int8、uint8、int16、uint16、int32、uint32 。
  
* 3）函数ones  用ones生成全1的矩阵
	* ones(n) : 生成n*n的全1矩阵
	* ones(m,n) : 生成m*n的全1矩阵
	* ones(size(A)) : 生成与矩阵A大小相同的全1矩阵
	* ones(m,n,p,…)生成m*n*p*….的全1的多维矩阵
	* ones(m,n,…,classname)制定数据类型为classname

* 4）函数zeros 函数zeros生成全0矩阵
	* zeros(n):生成n*n的全0矩阵
	* zeros(m,n:)生成m*n的全0矩阵
	* zeros(size(A)): 生成与矩阵A大小相同的全0矩阵
	* zeros (m,n,p,…)生成m*n*p*….的全0的多维矩阵
	* zeros (m,n,…,classname)指定数据类型为classname

* 5）函数rand 函数rand用来生成[0,1]之间均匀分布的随机函数，其调用格式是：
	* Y=rand:生成一个随机数
	* Y=rand(n):生成n*n的随机矩阵
	* Y=rand(m,n):生成m*n的随机矩阵
	* Y=rand(size(A)):生成与矩阵A大小相同的随机矩阵
	* Y=rand(m,n,p,…):生成m*n*p*…的随机数多维数组
	* 
* 6）函数randn 函数rand用来生成服从正态分布的随机函数，其调用格式是：
	* Y=randn:生成一个服从标准正态分布的随机数
	* Y=randn(n):生成n*n的服从标准正态分布的随机矩阵
	* Y=randn(m,n):生成m*n的服从标准正态分布的随机矩阵
	* Y=randn(size(A)):生成与矩阵A大小相同的服从标准正态分布的随机矩阵
	* Y=randn(m,n,p,…):生成m*n*p*…的服从标准正态分布的随机数多维数组

* 7) 函数diag 函数diag用来生成对角矩阵，
	* diag(v, k):生成一个对角矩阵，k为对角偏移量，负往下偏，正往上偏
	* 如：生成一个[0, C,D ; C,D,C ; 0,D,C]的三对角块矩阵：
	* 
			tic;
			C=ones(3,5);
			D=2*C;
			out=kron(diag(ones(1,7),1)+diag(ones(1,7),-1),D)+kron(diag(ones(1,8)),C);
			toc;

##1.3 矩阵元素的提取与替换
* 1）  单个元素的提取
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入b=a(1,2)
* 
		b =
		     2      

* 2）  提取矩阵中某一行的元素，
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入b=a(1,:)
* 
		b =
		     1     2     3

* 3）  提取矩阵中某一列：
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入b=a(:,1)
* 
		b =
		     1
		     3

* 4）  提取矩阵中的多行元素
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入b=a([1,2],:)
* 
		b =
		     1     2     3
		     3     4     5

* 5）  提取矩阵中的多列元素
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入b=a(:,[1,3])
* 
		b =
		     1     3
		     3     5

* 6）  提取矩阵中多行多列交叉点上的元素
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入b=a([1,2],[1,3])
* 
		b =
		     1     3
		     3     5

* 7）  单个元素的替换：
* 如：a=[1,2,3;3,4,5],运行后：
* 
		a =
		    1     2     3
		    3     4     5
* 输入：a(2,3)=-1
* 
		a =
		     1     2     3
		     3     4    -1
##1.4 矩阵元素的重排和复制排列
* 1） 矩阵元素的重排
	* B=reshape(A,m,n):返回的是一个m*n矩阵B，矩阵B的元素就是矩阵A的元素，若矩阵A的元素不是m*n个则提示错误。
	* B=reshape(A,m,n,p):返回的是一个多维的数组B，数组B中的元素个数* 和矩阵A中的元素个数相等
	* B=reshape(A,…,[],…):可以默认其中的一个维数
	* B=reshape(A,siz) : 由向量siz指定数组B的维数，要求siz的各元素之积等于矩阵A的元素个数

* 2） 矩阵的复制排列函数是repmat
	* B=repmat(A,n):返回B是一个n*n块大小的矩阵，每一块矩阵都是A
	* B=repmat(A,m,n):返回值是由m*n个块组成的大矩阵，每一个块都是矩阵A
	* B=repmat(A,[m,n,p,…]):返回值B是一个多维数组形式的块，每一个块都是矩阵A

##1.5 矩阵的翻转和旋转
* 1）矩阵的左右翻转 左右翻转函数是fliplr,调用格式：
	* B=fliplr(A):将矩阵A左右翻转成矩阵B。
* 输入：A=[1,2,3;3,4,2]
* 
		A =
		     1     2     3
		     3     4     2

* 输入：B=fliplr(A)
* 
		B =
		     3     2     1
			 2     4     3

* 2）矩阵上下翻转 函数：flipud，调用格式：
	* B=flipud(A):把矩阵A上下翻转成矩阵B

* 3）  多维数组翻转 函数：flipdim，调用格式：
	* B=flipdim(A,dim):把矩阵或多维数组A沿指定维数翻转成B

* 4）  矩阵的旋转  函数：rot90，调用格式：
	* B=rot90(A):矩阵B是矩阵A沿逆时针方向旋转90。得到的
	* B=rot90(A,k):矩阵B是矩阵A沿逆时针方向旋转k*90。得到的(要想顺时针旋转，k取-1)

##1.6 矩阵的生成与提取函数
* 1）  对角线函数 对角线函数diag既可以用来生成矩阵，又可以来提取矩阵的对角线元素，其调用格式：
	* a) A=diag(v,k):当v是有n个元素的向量，返回矩阵A是行列数为n+|k|的方阵。向量v的元素位于A的第k条对角线上。K=0 对应主对角线，k>0对应主对角线以上，k<0对应主对角线以下。
	* b) A=diag(v):将向量v的元素放在方阵A的主对角线上，等同于A=diag(v,k)中k=0的情况。
	* c) v=diag(A,k):提取矩阵A的第k条对角线上的元素于列向量v中。
	* d) v=diag(A):提取矩阵A的主对角线元素于v中，这种调用等同于v=diag(A,k)中k=0的情况。
* 2）  下三角阵的提取  用函数tril，调用格式：
	* a) L=tril(A): 提取矩阵A的下三角部分
	* b) L=tril(A,k):提取矩阵A的第k条对角线以下部分。K=0 对应主对角线，k>0对应主对角线以上，k<0对应主对角线以下。
* 3）  上三角阵的提取  函数triu，调用格式：
	* a) U=triu(A): 提取矩阵A的上三角部分元素
	* b) U=triu(A,k): 提取矩阵A的第k条对角线以上的元素。K=0 对应主对角线，k>0对应主对角线以上，k<0对应主对角线以下。

##1.7 关于matlab数组操作的讨论
* matlab是靠它灵活数组操作发的家，但是数组操作也是初学者最难理解的matlab特色之一，因为在其他语言中（如C、pascal）不存在对等的语法和语义。在5.x版中新增添的多维数组（N-D数组），进一步扩展了matlab的功能，迎合了许多多维的科学计算。但matlab中的很多函数只支持对向量和矩阵的操作，因此迫切要求我们掌握多维到一二维之间升降维数的命令。

* 一、matlab环境中对数据的物理存放形式
	* 在matlab中数据的逻辑形式可以表现出多维，但物理上在内存中的形式却是很简单按列存放的。这就说明为什么有一些函数只对列向量操作，而一些计算密集的函数，对矩阵的方向很敏感（如图像处理工具箱）。这些函数对于非列向量的输入要重新排序成列向量的形式。
	* 对于一个矩阵，在内存中的单元存放顺序是：第一列的单元，第二列单元，。。。最后一列。
	* 
			u =
			
			0.9501 0.4860 0.4565
			0.2311 0.8913 0.0185
			0.6068 0.7621 0.8214
			
			u(:)
			
			ans =
			
			0.9501
			0.2311
			0.6068
			0.4860
			0.8913
			0.7621
			0.4565
			0.0185
			0.8214

	* 对于多维的数组，则是把第二维以后的维数作为数据平面（plane）来看，存放的顺序是：第一个plane中的矩阵，第二个plane中的矩阵。
	* 
			u=[1,2;3,4];
			u(:,:,2)=[5,6;7,8];
			u(:,:,1) =
			
			1 2
			3 4
			
			
			u(:,:,2) =
			
			5 6
			7 8
			
			?u(:)
			
			ans =
			
			1
			3
			2
			4
			5
			7
			6
			8

	* 可以从单元的逻辑下标算出它所在的物理位置，相反的计算也是一定的。如维数[d1,d2,d3]的三维数组中的一个单元(a,b,c)的物理位置是(a-1)*d2*d3+(b-1)*d3+c

* 二、数组的下标
* 在matlab中的数组下标是很灵活的，可以进行维间的合并和扩展，维内的抽取和扩展。
	* 1、维内的抽取
	* 抽取的下标的数值要在被抽取数组维的大小以内，不能小于1或大于维的实际长度d。表示抽取下标的序列可以是任何数组形式，但matlab会自动将其转换为一列向量，如前面所描述的一样。该抽取下标序列可以有重复的数值，这样被抽取出来的序列值就会重复出现。这是一个很有用的操作，比如说已有一个表面上顶点的坐标的数组，现在要构造一个三角面的序列来表示该表面，这里就要从顶点数组中抽取数值，而且要重复，因为通常三个三角面要公用一个顶点。
	* 
			u([2,1,1],:,:)
			
			ans(:,:,1) =
			
			3 4
			1 2
			1 2
			
			
			ans(:,:,2) =
			
			7 8
			5 6
			5 6
			u(:,[2,1;2 2],:)
			
			ans(:,:,1) =
			
			2 2 1 2
			4 4 3 4
			
			
			ans(:,:,2) =
			
			6 6 5 6
			8 8 7 8

	* 2、维内的扩展
	* 在c或pascal之类的通用的算法语言中，要使数组动态增加或减少某些维的长度是很困难的事情，这里涉及的操作包括重新申请一个内存块，拷贝原有的数据（要重新计算地址），释放原有的块。而在matlab中它屏蔽了这些烦人的工作，对用户是透明的。
	* 在第一维（行）扩展，扩展只能在维末进行。
	* 
			u(3,:,:)=[10,11;12,13]
			
			u(:,:,1) =
			
			1 2
			3 4
			10 12
			
			
			u(:,:,2) =
			
			5 6
			7 8
			11 13

	* 在第一维删除一行，可以删除该维的中间部分
	* 
			u(3,:,:)=[]
			
			u(:,:,1) =
			
			1 2
			3 4
			
			
			u(:,:,2) =
			
			5 6
			7 8
	* 3、维间的抽取
	* matlab试图对你输入的多维数组的下标进行匹配。
	* 如果你给的下标数目小于实际该数组的维数，而且最后一个下标非“：”号，则matlab则会将后面的维都以下标为1以来处理。
	* 
			u(:,1)
			
			ans =
			
			1
			3

	* 如果最后一个下标为“：”，则将该维以及后面的维展成一维的向量，看看下面的例子。
	* 
			u(:,:)
			
			ans =
			
			1 2 5 6
			3 4 7 8
			
			u(1,:)
			
			ans =
			
			1 2 5 6

* 三、多维数组维间处理的几个函数
	* 1、最重要的函数应当是reshape，它的功能是将数据从一种空间形式转换为另一种，但又一个前提即这两个空间要能够匹配，它们所表示的点一样多。设一个空间Di，另一个空间Xi，如果D1*D2*D3……Dn=X1*X2*X3……*Xm则它们之间是匹配的，可以转化
	* 将u变为1*2*4的空间
	* 
			t=reshape(u,1,2,4)
			
			t(:,:,1) =
			
			1 3
			
			
			t(:,:,2) =
			
			2 4
			
			
			t(:,:,3) =
			
			5 7
			
			
			t(:,:,4) =
			
			6 8

	* 我们要注意的是，重构后数据的物理存储顺序没有变化，变得只是访问的下标。
	* 
			t(:)
			
			ans =
			
			1
			3
			2
			4
			5
			7
			6
			8

	* 以上是实际的存储次序，和前面的一样。

	* 2、size函数告诉我们输入的数组单元的维数和维的长度。
	* 
			size(t)
			
			ans =
			
			1 2 4

	* 3、ndims函数实际上可以写成length(size(x))
	* 
	* 4、cat函数连接两个多维数组，但要注意cat只能让你在一个维上连接，a、b两个多维数组在除了要连接的维上可以长度不同外，其他各维的尺寸必须一致。
	* 
			x=[0,0; 0 0];
			
			cat(3,x,u)
			
			ans(:,:,1) =
			
			0 0
			0 0
			
			
			ans(:,:,2) =
			
			1 2
			3 4
			
			
			ans(:,:,3) =
			
			5 6
			7 8
			
			cat(2,x,u) %2*2和2*1的无法连起来
			?? Error using ==> cat
			CAT arguments dimensions are not consistent.

	* 5、permute函数改变维的次序。
	* h=permute(u,[3,2,1]) %将原来的第三维变为第一维，而原来的第一维改成第三维
	* 
			h(:,:,1) =
			
			1 2
			5 6
			
			
			h(:,:,2) =
			
			3 4
			7 8
			
			h(:)
			
			ans =
			
			1
			5
			2
			6
			3
			7
			4
			8

	* 我们注意到数据的物理存储次序发生了变化。

	* 6、ipermute函数是permute的逆运算，其实只不过是的书写和阅读比较容易而已，把permute中的order参数改一改也能实现改功能，如果用type impermute你就可以看到permute函数的调用。

	* 7、shiftdim和permute差不多，但它是能循环移动维数。请注意它还有去奇异维（即该维的长度为1）的功能，这和squeeze函数一样，不同的是只去开头的奇异维。

	* 8、squeeze函数将多维数组中的奇异维去掉，请注意这样的操作不减少该数组空间上的单元的数目。squeeze操作在求导，差分等运算之前做预处理是很有必要的。

#二 矩阵与向量的引用
##2.1 概述
* Matlab中数组元素引用有三种方法：
	* 1.下标法(subscripts)
	* 2.索引法(index)
	* 3.布尔法(Boolean)

* 在使用这三种方法之前，大家头脑一定要清晰的记住，Matlab中数组元素是按列存储(与Fortran一样)，比如说下面的二维数组
* 
		A=
		     8     1     6
		     3     5     7
		     4     9     2

* Matlab的存储顺序是8,3,4,1,5,9,6,7,2，也就是说先行后列，对于3维数组呢，就是先行后列再页

* 对应个元素的索引和下标分别为
* 
		Element Index Subscripts
		8        1      (1,1)
		3        2      (2,1)
		4        3      (3,1)
		1        4      (1,2)
		5        5      (2,2)
		9        6      (3,2)
		6        7      (1,3)
		7        8      (2,3)
		2        9      (3,3)

* 从上面的例子中已经很清晰的说明了下标和索引的区别了，也就是说Matlab为没有个元素分配了一个唯一识别的ID(即index)

##2.2 下标法引用
* A(ii,jj)：其中ii和jj可以是一维向量、标量、“:”号或者“end”

* 大家对下标估计比较熟悉，由于在C语言中接触过，但是我这里需要强调的是，Matlab的下标是可以多行多列同时引用的，而像C语言等一次只能引用一个，比如
	* A(2:3,3:1:1)表示引用数组中的2~3行，3~1列对应的元素
	* A(:,end)表示引用最后一列元素，“:”表示所有列或行，“end”表示最后一列或列，“end-n”表示倒数第n行或列
	* A(1,end-1)表示引用第1行倒数第2个元素
	* A([2 1 3 3],[1 1 2 2 1])表示引用按两个向量引用指定的元素，即A中的第2,1,3,3行和第1,1,2,2,1列对应的元素

* 例子
* 
		>>A=magic(3)
		
		A =
		     8     1     6
		     3     5     7
		     4     9     2
		
		>>A(2:3,3:1:1)
		
		ans =
		     7     5     3
		     2     9     4
		
		>>A(:,end)
		
		ans =
		     6
		     7
		     2
		
		>>A(1,end-1)
		
		ans =
		     1
		
		>>A([2 1 3 3],[1 1 2 2 1])
		
		ans =
		     3     3     5     5     3
		     8     8     1     1     8
		     4     4     9     9     4
		     4     4     9     9     4

##2.3 索引法引用
* A(index)：index可以是任意的数组，index的元素必须是正整数，且不大于numel(A)，返回的是一个尺寸与index一样的数组

* 下标和索引之间可以通过ind2sub和sub2ind函数相互转换，具体可以看帮助，很简单：
	* [I,J] = ind2sub(siz,IND)
	* IND = sub2ind(siz,I,J)
 
* 还有使用A(:)就可以将数组A转换为列向量
	* A(8)：表示引用A的第8个元素
	* B=A([1 10 5 2 2 1 3])：表示依次引用A的第1,10,5,2,2,1,3个元素，返回与index尺寸相同的数组，也就是说size(B)=size(index)
	* A([2 5 9;1 1 1;8 5 6])：返回的时侯是一个3*3的矩阵

* 例子
* 
		>>A=magic(5)%括号中为索引值
		
		A =
		    17 (1)     24 (6)     1 (11)     8 (16)    15 (21)
		    23 (2)      5 (7)     7 (12)    14 (17)    16 (22)
		     4 (3)      6 (8)    13 (13)    20 (18)    22 (23)
		    10 (4)     12 (9)    19 (14)    21 (19)     3 (24)
		    11 (5)    18 (10)    25 (15)     2 (20)     9 (25)
		
		>>A(8)
		
		ans =
		     6
		
		>>A([1 10 5 2 2 1 3])
		
		ans =
		    17    18    11    23    23    17     4
		
		>>A([2 5 9;1 1 1;8 5 6])
		
		ans =
		    23    11    12
		    17    17    17
		     6    11    24

##2.4 布尔法引用
* A(X)：X是一个有0和1组成布尔型数据，且size(A)=size(X)，对应位置为1则留下该数据，0则去掉，最后按A中的存储顺序，返回一个列向量

* 假如说A是3*3的数组

* A(logical([1 0 0;0 1 0;0 0 1]))：表示引用了数组A的对角线元素，注意必须使用logical将0/1数组转换为布尔型

* 例子
* 
		>>A=magic(3)%生成一个3*3的数组
		
		A=
		     8     1     6
		     3     5     7
		     4     9     2
		
		>>x=logical([1 1 0;0 1 1;1 0 1])%将double转化为boolean型数据
		
		x =
		     1     1     0
		     0     1     1
		     1     0     1
		
		>>A(x)%引用对应位置为1的数据，返回列向量
		
		ans =
		     8
		     4
		     1
		     5
		     7
		     2
		
		>>x=A>5%是有了比较语句，返回布尔型数据，对应位置数据大于5的为1，否则为0
		
		x =
		     1     0     1
		     0     0     1
		     0     1     0
		
		>>A(x)%返回大于A中大于5的元素，其实该命令可以一次性执行A(A>5)或者find(A>5)，前者返回具体元素，后者返回大于5的数据的索引值
		
		ans =
		     8
		     9
		     6
		     7
		
		>>A(A>5)%一次性执行上面的命令
		
		ans =
		     8
		     9
		     6
		     7
		
		>>indx=find(A>5)%查找A中对于5的元素，返回它们的索引(index)值，此时我们可以通过A(index)返回具体的元素
		
		index =
		     1
		     6
		     7
		     8

#三 矩阵与向量的操作函数
##3.1 元素操作
####prod(a) - 向量a各个元素的积
* 例：
* 
		>> a=[1  5   6   3 ]
		a =
		     1     5     6     3
		>> prod(a)
		ans =
		    90

####cumprod(X) - 得到向量X累乘积向量
* 例：
* 
		a=[1  5   6   3 ]
		cumprod(a)		
		ans =
		     1     5    30    90

####find(X) - 找出向量/矩阵X中值非0的元素，返回下标列表或矩阵下标表示：[r, c, v]，v为逻辑数组，可选

* 例：
* 
		A= magic(4)
		A =
		    16     2     3    13
		     5    11    10     8
		     9     7     6    12
		     4    14    15     1
		
		[r,c,v]= find(A>10);
		
		r', c', v'
		ans =
		     1     2     4     4     1     3
		ans =
		     1     2     2     3     4     4
		ans =
		     1     1     1     1     1     1

##3.2 矩阵可视化
####imagesc(A) - 用不同颜色的各自代表矩阵的数值
* 例：
* 
		>> imagesc(A)
		(a figure)

* 可选操作：
	* colorbar - 显示颜色条及对应的数值
	* colormap(grey) - 设置为灰度图