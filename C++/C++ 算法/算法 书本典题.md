## 目录

[toc]

# 1 剑指 offer

## 03. 数组中重复的数字

> 找出数组中重复的数字。
>
> 在一个长度为 `n` 的数组 `nums` 里的所有数字都在 `0～n-1` 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
>
> **示例 1：**
>
> ```
> 输入：
> [2, 3, 1, 0, 2, 5, 3]
> 输出：2 或 3 
> ```
>
> **限制：**
>
> * `2 <= n <= 100000`

这题要**考察程序员的沟通能力**，问清楚需求是什么，是时间优先还是空间优先？亦或是两者兼顾？

不同的需求有这不同的解法！

### 解法一：哈希表

哈希表的特点是**快速查找**，但占用空间。

如果需求是时间优先，则考虑用哈希表，记录下每个出现过的元素，下次遇到时查询快速返回结果。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        vector<int> mp(nums.size(),0);
        for(const int &x: nums)
        {
            if(mp[x]) return x;
            ++mp[x];
        }
        return -1;
    }
};
```

### 解法二：排序

当数组有序的时候，是很容易找出重复元素的。

用**双指针处理首尾，序保证中间**，就能处理任意重复个数的情况。

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int i=1; i<nums.size(); ++i)
            if(nums[i]==nums[i-1])
                return nums[i];
        return -1;
    }
};
```

### 解法三：鸽巢原理

鸽巢原理

* 条件：数组中的每一个元素都有自己的归属位置（称为鸽巢），本质是元素与数组下标之间的**一一映射**
* 用法：给定数组元素，映射得到其归属位置，反之亦然

注意到元素范围与数组范围相同，存在一一映射，故可以使用鸽巢原理。

```c++
// 第一种用法：鸽巢标记
// 根据当前元素找到归属位置，然后给归属位置进行标记，表示该位置已有元素对应。
// 具体方法是，将归属位置上的元素减去 n，符号存储标记信息，数值存储元素信息。
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int n = nums.size();
        for(int i=0; i<n; ++i)
        {
            int x = nums[i]<0 ? nums[i]+n : nums[i];
            if(nums[x]<0)
                return x;
            else
                nums[x] -= n;
        }
        return -1;
    }
};
```

```c++
// 第二种用法：鸽巢归位
// 对于每个归属位置，循环判断当前元素是否归位。
// 如果没有归位，则当前元素应该回到其归属位置，于是将两位置元素交换。如果不能进行，说明当前元素重复，否则交换归位。
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int n = nums.size();
        for(int i=0; i<n; ++i)
            while(nums[i]!=i)
                if(nums[nums[i]]==nums[i])
                    return nums[i];
                else
                    swap(nums[i],nums[nums[i]]);
        return -1;
    }
};
```

# 2 程序员面试经典

## 17.21 直方图的水量

> 给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。
>
> ![img](img/rainwatertrap.png)
>
> 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。
>
> **示例:**
>
> ```
> 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出: 6
> ```

### (1) 解法一：动态规划

思想：逐元素分解型动规

原理：

1. 总储水量难以动规化，但发现
   * $总储水量 = \sum单方储水量$
   * $单方储水量 = 单方水高度-单方砖高度$
   * $单方水高度 = 两边最大高度的最小值$【重要】
2. 问题得到转化，新问题的关键在于求单方的两边最大高度，这个可以通过动态规划解决
   * $leftMax[i]$：下标 $i$ 及其左边的位置中，$\textit{height}$ 的最大高度
   * $rightMax[i]$：下标 $i$ 及其右边的位置中，$height$ 的最大高度

​    <img src="img/1.png" alt="fig1" style="zoom: 33%;" />

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size(), res = 0;
        if(!n) return 0; // 处理平凡情况
        vector<int> leftMax(n,height[0]), rightMax(n,height[n-1]); // 动规数组
        for(int i=1; i<n; ++i)
            leftMax[i] = max(leftMax[i-1], height[i]); // 动规求单方的左边最大高度
        for(int i=n-2; i>=0; --i)
            rightMax[i] = max(rightMax[i+1], height[i]); // 动规求单方的右边最大高度
        for(int i=0; i<n; ++i)
            res += min(leftMax[i], rightMax[i]) - height[i]; // 求总储水量
        return res;
    }
};
```

### (2) 解法二：单调栈

思想：单调栈，最小对齐

原理：

1. **单调栈**
   * 进栈：**捕获**当前连续的单调序列
   * 弹栈：**对齐**当前违反单调的序列
     * 高度对齐过程可看成一种**“填挖”**，取两边的左、右、最大、最小高度
     * 然后元素弹栈可以看成填挖对齐后，等高元素的合并、吸收，最终得到**省略型表示**
   * 特性：**检测**“凹”或“凸”模式
     * 弹栈时必然是违反了单调性，出现了“凹”或“凸”形状

2. 储水需要“凹”型模式，而单调栈能检测这种模式
   * 每次出现“凹”型模式，如果栈中至少有两个元素（这两个元素必然单调减），就说明可以储水
   * 使用“最小对齐”计算储水量（高度=最短板-桶底，长度=两边距离-1）

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0, top; // 结果、栈顶缓存
        stack<int> stk; // 单调栈，因为需要用下标计算，故存储的是下标
        for(int i=0; i<height.size(); ++i) // 遍历每一个元素
        {
            while(!stk.empty()&&height[i]>=height[stk.top()]) // 违反单调性
            {
                top = stk.top();
                stk.pop(); // 弹栈
                if(!stk.empty()) // 出现凹型水槽
                    res += (min(height[stk.top()],height[i])-height[top])*(i-stk.top()-1); // 计算储水量
            }
            stk.push(i); // 当前元素进栈
        }
        return res;
    }
};
```

### (3) 解法三：双指针

思想：双指针收缩窗口优化动规数组

原理：

1. **双指针**

   * <u>双指针收缩窗口</u>
     * 左、右指针分别**维护**左前段和右后段的性质
     * 根据左右段的性质**捕获**另一目标
     * 根据左右指针当前情况判断**前进**方向

   * <u>双指针滑动窗口</u>，其核心是利用两段性质：
     * 右指针**探索**，维持当前窗口目标成立，或使当前窗口目标不成立，转左
     * 左指针**维护**，维持当前窗口目标不成立，或使当前窗口目标成立，转右
     * **捕获**满足另一目标的有效序列

2. 动态规划中维护着两个最大值数组，且

   * 数组的用途是获得 $leftMax[i]$ 与 $rightMax[i]$ 的最小值，其可以通过局部判定：
     * 若 $leftMax[i]<rightMax[j]$，则 $leftMax[i]$ 是 $leftMax[i]$ 与 $rightMax[i]$ 的最小值
     * 若 $leftMax[i]>rightMax[j]$，则 $rightMax[j]$ 是 $leftMax[j]$ 与 $rightMax[j]$ 的最小值
   * $leftMax$ 向右移动，$rightMax$ 向左移动

3. 因此动规中的数组完全可以用双指针代替

   * 左右指针分布维护左前段和右后段的最大值
   * 根据左右段的最大值比较，选出较小的值计算单方储水量
   * 具有较小值的那段继续前进

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int left=0, right=height.size()-1, leftMax=0, rightMax=0, res=0; // 初始化
        while(left<right) // 只要还能收缩（left 严格小于 right 才有蓄水的可能）
        {
            leftMax = max(leftMax, height[left]); // 更新左前段性质
            rightMax = max(rightMax, height[right]); // 更新右后段性质
            if(leftMax<rightMax) // 捕获另一目标
            {
                res += leftMax - height[left];
                ++left;
            }
            else
            {
                res += rightMax - height[right];
                --right;
            }
        }
        return res; // 返回结果
    }
};
```

