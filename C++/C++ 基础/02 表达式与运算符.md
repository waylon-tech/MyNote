### 目录

[toc]

### 2.1 概念

#### 2.1.1 基本概念

##### 2.1.1.1 表达式

表达式由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果。

##### 2.1.1.2 运算符

C++ 定义有一元运算符、二元运算符和一个三元算符。函数调用也是一种特殊的运算符，只不过运算对象的数量无限制。

运算符和运算对象可以相互组合形成复杂运算，运算对象也可以根据情况转换类型。

在处理类类型的运算对象时，用户可以重载运算符，重载的内容包括运算对象类型、返回值类型、运算逻辑，但运算对象个数、运算符优先级和结合律无法改变。

【注】多余的空语句并非总是无害，比如会占用了循环中的语句。

##### 2.1.1.3 左值和右值

定义：

* 当一个对象被用作右值的时候，用的是对象的值（内容 $\sim$ 家具，只能用不能动）
* 当一个对象被用作左值的时候，用的是对象的身份（空间+内容 $\sim$ 房子+家具，能用也能动）

原则：

* 在需要右值的地方可以用左值代替，反之不能
* 用左值代替时，实际使用的是它的值（内容）

例子：

* 赋值运算符（`=`）：需要左值作为左侧运算对象，结果仍是左值

* 取地址符（`&`）：作用于一个左值运算对象，返回右值运算对象（指针）

* 解引用运算符（`*`）和下标运算符（`[]`）：求值结果都是左值

* 递增递减运算符（`++`，`--`）：作用于左值运算对象，前置版本结果为左值

* 关键字 `decltype`：对于表达式（非变量），如果求值结果为左值，则得到引用类型

  ```c++
  decltype(*p);	// 解引用运算符生成左值，故结果是int&
  decltype(&p);	// 取地址运算符生成右值，故结果是int**
  ```

【悟】左值像对象，右值像纯值；左值联系内存，右值脱离内存。

【链】左值引用与右值引用：`12.1.2 右值引用`。

#### 2.1.2 优先级与结合律

复合表达式（compound expression）是指含有两个或多个运算符的表达式。

复合表达式的值需要运算符和运算对象合理组合，而优先级与结合律决定了运算对象的组合方式。

优先级与结合律的顶层描述为：

* 高优先级运算符对象先于低优先级运算符对象参与运算
* 优先级相同时，运算对象的组合有结合律确定
* 括号无视优先级与结合律（具有最高优先级）

`2.2 运算符详解` 中罗列了全部的运算符及其优先级与结合律。

#### 2.1.3 求值顺序

运算对象的求值顺序与结合律无关，C++ 也没有规定运算符的求值顺序。

对于没有指定执行顺序的两个运算对象：

* 如果它们既不改变同一对象的状态，也不执行 IO 任务，则调用顺序不受影响：

  ```c++
  // 根据优先级，g() 的返回值与 h() 的返回值相乘
  // 根据结合律，f() 的返回值与 g()*h() 的积相加
  // 求值顺序不做规定，故 4 个函数的调用顺序随机，且无影响
  f() + g() * h() + j()
  ```

* 如果它们改变了同一对象的状态，或者执行了 IO 任务，将产生<u>未定义</u>行为：

  ```c++
  int i =0;
  cout << i << " " << ++i << endl; // 先求++i还是先求i都有可能，因此该表达式是未定义的
  ```

【注1】只有 4 种运算符明确规定了运算对象的求值顺序：

* 逻辑与运算符（`&&`）- 短路求值顺序
* 逻辑或运算符（`||`）- 短路求值顺序
* 条件运算符（`?:`）    - 短路求值顺序
* 逗号运算符（`,`）      - 顺序求值顺序

【注2】书写符合表达式时，建议按照以下两点：

* 不确定情况时，要善用括号
* 如果改变了某个运算对象的值，在表达式的其他地方不再使用
  * 例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时（不存在如何选择求值顺序问题），规则无效
  * 例如：`*++iter`，这时求值顺序不会成为问题

### 2.2 运算符详解

下面的众多表格罗列了所有的运算符，**靠前的组中运算符的优先级更高，同组的运算符优先级相同。**

对于有左值运算对象要求的，会专门用 `lvalue` 写出，其余都是右值（意味着也可以放左值）。

运算符作用类型和结果类型介绍：

* 算术运算符：作用于任意算数类型，以及能任意转换为算数类型的类型
  * 可作用于指针，返回运算对象值的一个（提升后的副本）
  * 运算对象和求值结果都是右值
* 逻辑运算符：作用于任意能转换成布尔值的类型
  * 运算对象和求值结果都是右值
* 关系运算符：作用于算数类型或指针类型
  * 运算对象和求值结果都是右值
* 赋值运算符
  * 左侧运算对象（也是结果）必须是一个可修改的左值
* 递增/递减运算符
  * 作用于任意算数类型和可转换算数类型，还可用于迭代器
  * 运算对象必须为左值，前置版本将对象本身作为左值返回，后置版本将对象原始值的**副本**作为右值返回
  * 【注】除非必须，否则不用递增/递减运算符的后置版本，避免增加副本增加开销
* 成员访问运算符
  * 箭头运算符作用于指针类型的运算对象，结果是一个左值
  * 点运算符的结果分两种情况：如果成员所属的对象是左值，则结果是左值，反之结果是右值
* 条件运算符
  * `expr1`和`expr2`是两个类型相同或可能转换为某个公共类型的表达式
  * `expr1`和`expr2`都是左值或能转换成同一种左值类型时，结果为左值，否则结果都是右值
  * 【注】条件运算符优先级非常低，因此当一条在长表达式中最好加上括号
* 位运算符
  * 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合
  * 【注】“小整型”运算对象会自动提升称为较大的整数类型（这条规则也是下节类型转换的一部分）
  * 【注】带符号运算对象的处理依赖于机器，因此建议仅对无符号数进行位运算
* `sizeof` 运算符
  * `sizeof` 运算符返回目标结果类型的大小，并且并不计算其运算对象的值
* 逗号运算符
  * 逗号运算符的结果是右侧表达式的值，左值或右值也看这个值

| 运算符 | 结合律 | 功能           | 用法              | 参考页码 |
| ------ | ------ | -------------- | ----------------- | -------- |
| `::`   | 左     | 全局作用域     | `::name`          | 256      |
| `::`   | 左     | 类作用域       | `class::name`     | 79       |
| `::`   | 左     | 命名空间作用域 | `namesapce::name` | 74       |

| 运算符 | 结合律 | 功能         | 用法                                 | 参考页码          |
| ------ | ------ | ------------ | ------------------------------------ | ----------------- |
| `.`    | 左     | 对象成员选择 | `object.member`                      | 20 成员访问运算符 |
| `->`   | 左     | 指针成员选择 | `pointer->member`                    | 98 成员访问运算符 |
|        |        |              | 【注】`ptr->mem` 等价于 `(*ptr).mem` |                   |
| `[]`   | 左     | 下标         | `expr[expr]`                         | 104               |
| `()`   | 左     | 函数调用     | `name(expr_list)`                    | 20                |
| `()`   | 左     | 类型构造     | `type(expr_list)`                    | 145               |

| 运算符          | 结合律 | 功能         | 用法                           | 参考页码            |
| --------------- | ------ | ------------ | ------------------------------ | ------------------- |
| `++`            | 右     | 后置递增运算 | `lvalue++`                     | 131 递增/递减运算符 |
|                 |        |              | 【注】一种常见用法是 `*pbeg++` |                     |
| `--`            | 右     | 后置递减运算 | `lvalue--`                     | 131 递增/递减运算符 |
|                 |        |              | 【注】一种常见用法是 `*pbeg--` |                     |
| `typeid`        | 右     | 类型ID       | *`typeid`*`(type)`             | 731                 |
| `typeid`        | 右     | 运行时类型ID | *`typeid`*`(expr)`             | 731                 |
| `explicit cast` | 右     | 类型转换     | `cast_name<type>(expr)`        | 144                 |

| 运算符     | 结合律 | 功能         | 用法                                                         | 参考页码            |
| ---------- | ------ | ------------ | ------------------------------------------------------------ | :------------------ |
| `++`       | 右     | 前置递增运算 | `++lvalue`                                                   | 131 递增/递减运算符 |
| `--`       | 右     | 前置递减运算 | `--lvalue`                                                   | 131 递增/递减运算符 |
| `~`        | 右     | 位求反       | `~expr`                                                      | 136 位运算符        |
| `!`        | 右     | 逻辑非       | `!expr`                                                      | 126 逻辑运算符      |
| `-`        | 右     | 一元负号     | `-expr`                                                      | 124 算数运算符      |
|            |        |              | 【注】布尔值不应该参加运算：若 `b=true`，则 `bool b2=-b`过程<br />            中，`b`提升为 `int` 类型值1，然后取负值 `-1` 再赋给 `b2` 为 `true`！ |                     |
| `+`        | 右     | 一元正号     | `+expr`                                                      | 124 算数运算符      |
| `*`        | 右     | 解引用       | `*expr`                                                      | 48                  |
| `&`        | 右     | 取地址       | `&lvalue`                                                    | 47                  |
| `()`       | 右     | 类型转换     | `(type)expr`                                                 | 145                 |
| `sizeof`   | 右     | 对象的大小   | *`sizeof`*`expr`                                             | 139 `sizeof` 运算符 |
|            |        |              | 【注1】`sizeof` 不会计算运算对象的值，因此即使 `sizeof *p` 中 `p` 空也可以 |                     |
|            |        |              | 【注2】即使没有类的具体对象，通过 `sizeof 类::成员` 也能得到类型大小 |                     |
|            |        |              | 【注3】对 `char` 或 `char` 的表达式指向 `sizeof` 运算，结果的 `1` |                     |
|            |        |              | 【注4】对数组执行，得到整个数组所占空间大小，数组名不会转为指针处理 |                     |
|            |        |              | 【注5】对 `string` 或 `vector` 对象执行只会得到该类型固定部分的大小 |                     |
| `sizeof`   | 右     | 类型的大小   | *`sizeof`*`(type)`                                           | 139 `sizeof` 运算符 |
| `sizeof`   | 右     | 参数包的大小 | *`sizeof...`*`(name)`                                        | 619 `sizeof` 运算符 |
| `new`      | 右     | 创建对象     | *`new`*`type`                                                | 407                 |
| `new[]`    | 右     | 创建数组     | *`new`*`type[size]`                                          | 407                 |
| `delete`   | 右     | 释放对象     | *`delete`*`expr`                                             | 409                 |
| `delete[]` | 右     | 释放数组     | *`delete[]`*`expr`                                           | 409                 |
| `noexcept` | 右     | 能否抛出异常 | *`noexcept`*`(expr)`                                         | 690                 |

| 运算符 | 结合律 | 功能                   | 用法                  | 参考页码 |
| ------ | ------ | ---------------------- | --------------------- | -------- |
| `->*`  | 左     | 指针指向成员选择的指针 | `ptr->*ptr_to_member` | 740      |
| `.*`   | 左     | 对象指向成员选择的指针 | `obj.*ptr_to_number`  | 740      |

| 运算符 | 结合律 | 功能         | 用法                                                | 参考页码       |
| ------ | ------ | ------------ | --------------------------------------------------- | -------------- |
| `*`    | 左     | 乘法         | `expr * expr`                                       | 124 算数运算符 |
| `/`    | 左     | 除法         | `expr / expr`                                       | 124 算数运算符 |
|        |        |              | 【注1】整数与整数相除的结果仍然是整数，直接舍弃小数 |                |
|        |        |              | 【注2】两个运算对象同号结果为正，异号结果为负       |                |
| `%`    | 左     | 取模（求余） | `expr % expr`                                       | 124 算数运算符 |
|        |        |              | 【注1】参与取余的运算对象必须是整数类型             |                |
|        |        |              | 【注2】如果 `m%n` 不为0，则结果符号与 `m` 相同      |                |

| 运算符 | 结合律 | 功能 | 用法                                        | 参考页码       |
| ------ | ------ | ---- | ------------------------------------------- | -------------- |
| `+`    | 左     | 加法 | `expr + expr`                               | 124 算数运算符 |
| `-`    | 左     | 减法 | `expr - expr`                               | 124 算数运算符 |
|        |        |      | 【注1】对于带符号数，左移操作是未定义的行为 |                |

| 运算符 | 结合律 | 功能     | 用法                                                         | 参考页码     |
| ------ | ------ | -------- | ------------------------------------------------------------ | ------------ |
| `<<`   | 左     | 向左移位 | `expr << expr`                                               | 136 位运算符 |
|        |        |          | 【注1】移位运算符右侧运算对象必须非负，然后将移动后的左侧运算对象的拷贝作为求值结果 |              |
|        |        |          | 【注2】左移运算在右侧插入为 `0` 的二进制位                   |              |
|        |        |          | 【技】制造指定位 `1` 的二进制数的方法：`1UL << 27`           |              |
| `>>`   | 左     | 向右移位 | `expr >> expr`                                               | 136 位运算符 |
|        |        |          | 【注1】移位运算符右侧运算对象必须非负，然后将移动后的左侧运算对象的拷贝作为求值结果 |              |
|        |        |          | 【注2】当左侧运算对象无符号时，在左侧插`0`；<br />              当左侧运算对象有符号时，在左侧视具体情况插入符号位或 `0` |              |

| 运算符 | 结合律 | 功能     | 用法                                                         | 参考页码       |
| ------ | ------ | -------- | ------------------------------------------------------------ | -------------- |
| `<`    | 左     | 小于     | `expr < expr`                                                | 126 关系运算符 |
| `<=`   | 左     | 小于等于 | `expr <= expr`                                               | 126 关系运算符 |
| `>`    | 左     | 大于     | `expr > expr`                                                | 126 关系运算符 |
| `>=`   | 左     | 大于等于 | `expr >= expr`                                               | 126 关系运算符 |
|        |        |          | 【注】除非比较对象是布尔类型，否则不要用布尔字面值作为运算对象，以上都是 |                |

| 运算符 | 结合律 | 功能   | 用法                                                         | 参考页码       |
| ------ | ------ | ------ | ------------------------------------------------------------ | -------------- |
| `==`   | 左     | 相等   | `expr == expr`                                               | 126 关系运算符 |
| `!=`   | 左     | 不相等 | `expr != expr`                                               | 126 关系运算符 |
|        |        |        | 【注】除非比较对象是布尔类型，否则不要用布尔字面值作为运算对象，以上都是 |                |

| 运算符 | 结合律 | 功能 | 用法          | 参考页码     |
| ------ | ------ | ---- | ------------- | ------------ |
| `&`    | 左     | 位与 | `expr & expr` | 136 位运算符 |

| 运算符 | 结合律 | 功能   | 用法          | 参考页码     |
| ------ | ------ | ------ | ------------- | ------------ |
| `^`    | 左     | 位异或 | `expr ^ expr` | 136 位运算符 |

| 运算符 | 结合律 | 功能 | 用法          | 参考页码     |
| ------ | ------ | ---- | ------------- | ------------ |
| `|`    | 左     | 位或 | `expr | expr` | 136 位运算符 |

| 运算符 | 结合律 | 功能   | 用法                | 参考页码       |
| ------ | ------ | ------ | ------------------- | -------------- |
| `&&`   | 左     | 逻辑与 | `expr && expr`      | 126 逻辑运算符 |
|        |        |        | 【注1】短路求值顺序 |                |

| 运算符 | 结合律 | 功能   | 用法                | 参考页码       |
| ------ | ------ | ------ | ------------------- | -------------- |
| `||`   | 左     | 逻辑或 | `expr || expr`      | 126 逻辑运算符 |
|        |        |        | 【注1】短路求值顺序 |                |

| 运算符 | 结合律 | 功能 | 用法                   | 参考页码       |
| ------ | ------ | ---- | ---------------------- | -------------- |
| `? :`  | 右     | 条件 | `expr ? expr1 : expr2` | 134 条件运算符 |

| 运算符 | 结合律 | 功能 | 用法                                 | 参考页码       |
| ------ | ------ | ---- | ------------------------------------ | -------------- |
| `=`    | 右     | 赋值 | `lvalue = expr`                      | 129 赋值运算符 |
|        |        |      | 【注】相比符合赋值运算符，它求值两次 |                |

| 运算符           | 结合律 | 功能     | 用法                 | 参考页码       |
| ---------------- | ------ | -------- | -------------------- | -------------- |
| `*=`, `/=`, `%=` | 右     | 复合赋值 | `lvalue += expr` 等  | 129 赋值运算符 |
| `+=`, `-=`       | 右     | 复合赋值 | `lvalue -= expr` 等  | 129 赋值运算符 |
| `<<=`, `>>=`     | 右     | 复合赋值 | `lvalue >>= expr` 等 | 129 赋值运算符 |
| `&=`, `|=`, `^=` | 右     | 复合赋值 | `lvalue ^= expr` 等  | 129 赋值运算符 |

| 运算符  | 结合律 | 功能     | 用法            | 参考页码 |
| ------- | ------ | -------- | --------------- | -------- |
| `throw` | 右     | 抛出异常 | *`throw`*`expr` | 173      |

| 运算符 | 结合律 | 功能 | 用法                                              | 参考页码       |
| ------ | ------ | ---- | ------------------------------------------------- | -------------- |
| `,`    | 左     | 逗号 | `expr, expr`                                      | 140 逗号运算符 |
|        |        |      | 【注1】规定了求值顺序，真正的结果是右侧表达式的值 |                |

### 2.3 类型转换

#### 2.3.1 隐式转换

两个不同类型的对象进行运算，会进行自动类型转换以统一类型，称为隐式转换。

##### 2.3.1.1 隐式转换发生情形

* 在大多数表达式，比 `int` 类型小的整型值首先提升为较大的整数类型
* 在条件中，非布尔值转换为布尔类型
* 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
* 如果算数运算或关系运算的运算对象有多种类型，需要转换成同一种类型
* 函数调用时也会发生类型转换（==第6章==）

##### 2.3.1.2 算数类型的转换

算数类型的转换遵循一个原则，就是尽可能避免损失精度，即运算对象将转换成最宽的类型。

下面是算数类型转换的一般流程：

* 首先执行整型提升，将小整数类型转换成较大的整数类型，即上述第 1 点
* 如果运算对象是带符号类型和无符号类型，且无符号类型不小于带符号类型
  * 那么，带符号类型转换为无符号类型
  * 【注】如果此时带符号类型还是负数，将会有下例第（5）点的问题
* 如果运算对象是带符号类型和无符号类型，且带符号类型大于无符号类型
  * 如果带符号类型能够容纳无符号类型，则无符号类型转换为带符号类型
  * 如果带符号类型能够还不能容纳无符号类型，则带符号类型转换为无符号类型

<u>例：算数类型的转换</u>

（1）布尔值转换

```c++
布尔类型 = 非布尔类型的算数值
```

初始值为 `0`，则结果为 `false`，否则结果为 `true`。

```c++
整数类型 = 布尔类型值
```

初始值为 `false` 则结果为0，初始值为 `true` 则结果为 `1`.

（2）整数与浮点数转换

```c++
整数类型 = 浮点数
```

结果值仅保留浮点数中的整数部分。

```c++
浮点类型 = 整数值
```

增加小数部分，记为 `0`。如果整数过大超过浮点类型容量，则可能会损失精度。

（3）无符号类型赋值

```c++
无符号类型 = 超出范围的值
```

结果为初始值对无符号类型表示数值总数取模后的余数。

（4）带符号类型赋值

```c++
带符号类型 = 超出范围值
```

结果是未定义的（`undefined`）。

（5）含有无符号类型的表达式

* 运算无符号：当一个算数表达式中既有无符号数又有 `int` 值时，那个 `int` 值就会转换成无符号数。

  ```c++
  unsigned u = 10;
  int i = -42;
  std::cout << i + i << std::endl; // 输出 -84
  std::cout << u + i << std::endl; // 如果 int 占 32 为，输出 4294967264
  ```

  ```c++
  // 【注】顺序容器中的 size_type 类型（别名）也是无符号的
  string s = "abcdef";
  int i = -42
  bool b = s.size() < i; 		 // s.size() 是 string::size_typ 类型的无符号数，负值 i 会自动转换成较大的无符号值
  std::cout << b << std::endl; // 输出 true
  ```

* 结果无符号：当从无符号数中减去一个值时，不管这个值是不是无符号数，都会对无符号类型范围取模，以确保结果非负。

  ```c++
  unsigned u1 = 42, u2 = 10;
  std::cout << u1 - u2 << std::endl; // 输出 32
  std::cout << u2 - u1 << std::endl; // 如果 int 占 32 为，输出 4294967264
  ```

【注】上述两个规则同样作用于无符号数的循环控制变量，因此要注意避免造成死循环。

##### 2.3.1.3 其他隐式类型转换

**数组转换成指针**

* 大多数用到数组的表达式中，数组自动转换成首元素指针
* 当数组名被用作 `decltype` 关键字参数，或者取地址符（`&`）、`sizeof` 及 `typeid` 的运算对象时，不会自动转换
* 用引用来初始化数组（==`p102 3.5.1`==）`int (&arrRef)[10] = arr` 时，不会自动转换

**指针的转换**

* 常量整数值 `0` 或字面值 `nullptr` 能转换成任意指针类型
* 指向任意非常量的指针能转换成 `void*`
* 指向任意对象的指针能转换成 `const void*`

**转换成布尔类型**

* 指针或算数类型值非 `0`，则转成 `false`，否则为 `true`

**转换成常量**

* 常量引用可以绑定非常量
* 常量指针可以指向非常量

**类类型定义的转换**

* 类类型能定义有编译器自动执行的转换，不过编译器**每次只能执行一种类类型定义的转换**

#### 2.3.2 显式转换

将某种类型显示地转换为另一种类型，称为强制类型转换。

【注】建议避免强制类型转换：

* 每写一条强制类型转换语句，都应该反复斟酌能否以其他方式实现
* 就算无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型所做的假定，减少错误发生的机会

##### 2.3.2.1 命名的强制类型转换

语法：

```c++
cast-name<type>(expression);
```

其中：

* `type` 是转换的目标类型
* `expression` 是要转换的值
  * 如果 `type` 是引用类型，则结果是左值
* `cast-name` 是以下的一种：
  * `static_cast`
  * `dynamic_cast`
  * `const_cast`
  * `reinterpret_cast`

**1）`static_cast`**

任何具有明确定义的类型转换，只要不包含底层 `const`，都可以使用 `static_cast`。

```c++
double slope = static_cast<double>(j) / i;
```

* 应用1：把一个较大的算数类型赋值给较小的类型
* 应用2：执行编译器无法自动执行的类型转换]

【注1】这是旧式强制类型转换（下述）最经常对应的情况。

【注2】`static_cast` 允许将一个左值转换为右值，因为截断一个左值是安全的（`12.1.3.2 std::move 的原理`）。

**2）`dynamic_cast`**

支持运行时类型识别，将在 ==`p730 19.2`== 进行详细介绍。

**3）`const_cast`**

`const_cast` 只能改变运算对象的底层 `const`，因此 `type` 里的目标类型必须是指针、引用或指向对象类型成员的指针（`1.4.4 顶层 const 和底层 const` ）。

```c++
const char *pc;
char *p = const_cast<char*>(pc);
```

* 应用1：去掉 `const` 性质（cast away the const）
* 应用2：在函数重载的上下文中使用（`4.4.3 const_cast 和重载`）

【注】除了在重载函数中有必要使用 `const_cast`，其他情况下使用都意味着程序存在某种设计缺陷。

**4）`reinterpret_cast`**

`reinterpret_cast` 通常为运算对象的位模式提供较低层次上的重新解释。

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

【注】谨慎使用，必须对涉及的类型和编译器实现的转换过程都非常了解。

##### 2.3.2.2 旧式的强制类型转换

```c++
type (expr);	// 函数形式的强制类型转换
(type) expr;	// C 语言风格的强制类型转换
```

新旧两式的联系：

* 如果旧式强制类型转换可以换成 `const_cast` 或 `static_cast`，则其行为与之一致
* 如果替换后不合法，则旧式强制类型转换与 `reinterpret_cast` 功能类似
